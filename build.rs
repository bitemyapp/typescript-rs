use regex::Regex;
use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;
use std::process::Command;

#[derive(Debug, Deserialize)]
struct DiagnosticMessage {
    category: String,
    code: i32,
    #[serde(rename = "reportsUnnecessary", default)]
    reports_unnecessary: bool,
    #[serde(rename = "reportsDeprecated", default)]
    reports_deprecated: bool,
    #[serde(rename = "elidedInCompatabilityPyramid", default)]
    elided_in_compatability_pyramid: bool,
    #[serde(skip)]
    key: String,
}

const HEADER: &str = r#"// GENERATED BY build.rs; DO NOT EDIT
#![allow(non_upper_case_globals)]

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Category {
    Warning,
    Error,
    Suggestion,
    Message,
}

#[derive(Debug)]
pub struct Message {
    code: i32,
    category: Category,
    key: &'static str,
    text: &'static str,
    reports_unnecessary: bool,
    elided_in_compatability_pyramid: bool,
    reports_deprecated: bool,
}

impl Message {
    pub fn code(&self) -> i32 { self.code }
    pub fn category(&self) -> Category { self.category }
    pub fn key(&self) -> &str { self.key }
    pub fn message(&self) -> &str { self.text }
    pub fn reports_unnecessary(&self) -> bool { self.reports_unnecessary }
    pub fn elided_in_compatability_pyramid(&self) -> bool { self.elided_in_compatability_pyramid }
    pub fn reports_deprecated(&self) -> bool { self.reports_deprecated }
}
"#;

const DIAGNOSTIC_MESSAGES_PATH: &str =
    "./typescript-go/_submodules/TypeScript/src/compiler/diagnosticMessages.json";

const DIAGNOSTIC_MESSAGES_OUTPUT_PATH: &str = "src/compiler/diagnostics/generated.rs";
fn main() -> io::Result<()> {
    // Tell Cargo to re-run this build script if the input file changes
    println!("cargo:rerun-if-changed={}", DIAGNOSTIC_MESSAGES_PATH);
    println!("cargo:rerun-if-changed=build.rs");

    // Configure paths
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let input_path = DIAGNOSTIC_MESSAGES_PATH;

    // Write to src directory instead of OUT_DIR
    let output_path = Path::new(&manifest_dir).join(DIAGNOSTIC_MESSAGES_OUTPUT_PATH);

    // Create output directory if it doesn't exist
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)?;
    }

    // Read and parse the input JSON file
    let json_content = fs::read_to_string(&input_path)?;
    let raw_diagnostic_messages: HashMap<String, DiagnosticMessage> =
        serde_json::from_str(&json_content)?;

    // Create vector of diagnostic messages with keys
    let mut diagnostic_messages = Vec::new();
    for (k, mut v) in raw_diagnostic_messages {
        v.key = k.clone();
        diagnostic_messages.push(v);
    }

    // Sort by code
    diagnostic_messages.sort_by_key(|m| m.code);

    // First write to a temporary buffer to ensure we're not writing a partial file
    let mut buffer = Vec::new();

    // Write the header
    buffer.write_all(HEADER.as_bytes())?;
    buffer.write_all(b"\n")?;

    // Write each diagnostic message
    for m in &diagnostic_messages {
        let (const_name, key) = generate_constant_name(&m.key, m.code);

        writeln!(buffer, "pub static {}: &Message = &Message {{", const_name)?;
        writeln!(buffer, "    code: {},", m.code)?;
        writeln!(buffer, "    category: Category::{},", m.category)?;
        writeln!(buffer, "    key: \"{}\",", key)?;
        writeln!(buffer, "    text: {},", to_json_string(&m.key))?;
        writeln!(
            buffer,
            "    reports_unnecessary: {},",
            m.reports_unnecessary
        )?;
        writeln!(
            buffer,
            "    elided_in_compatability_pyramid: {},",
            m.elided_in_compatability_pyramid
        )?;
        writeln!(buffer, "    reports_deprecated: {},", m.reports_deprecated)?;
        writeln!(buffer, "}};")?;
        buffer.write_all(b"\n")?;
    }

    // Only update the file if its contents would change
    let should_write = match fs::read(&output_path) {
        Ok(existing_content) => buffer != existing_content,
        Err(_) => true, // File doesn't exist or can't be read, so write it
    };

    if should_write {
        println!("Writing generated file to {}", output_path.display());
        let mut file = File::create(&output_path)?;
        file.write_all(&buffer)?;
    } else {
        println!("File {} unchanged, not overwriting", output_path.display());
    }

    println!(
        "cargo:rustc-env=DIAGNOSTICS_GENERATED_PATH={}",
        output_path.display()
    );

    Ok(())
}

fn generate_constant_name(orig_name: &str, code: i32) -> (String, String) {
    // Convert to snake_case
    let mut snake_case = String::new();
    let mut prev_is_lowercase = false;

    for (i, c) in orig_name.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 && prev_is_lowercase {
                snake_case.push('_');
            }
            snake_case.push(c.to_lowercase().next().unwrap());
            prev_is_lowercase = false;
        } else if c.is_alphabetic() || c.is_digit(10) {
            snake_case.push(c);
            prev_is_lowercase = c.is_lowercase();
        } else {
            // Replace special characters with descriptive text
            match c {
                '*' => snake_case.push_str("_asterisk"),
                '/' => snake_case.push_str("_slash"),
                ':' => snake_case.push_str("_colon"),
                _ => snake_case.push('_'),
            }
            prev_is_lowercase = true;
        }
    }

    // Replace multiple underscores with a single one
    let multiple_underscore_re = Regex::new(r"_+").unwrap();
    let mut snake_case = multiple_underscore_re
        .replace_all(&snake_case, "_")
        .to_string();

    // Remove leading/trailing underscores
    snake_case = snake_case.trim_matches('_').to_string();

    // Create key (truncated to 100 chars + code)
    let mut key = snake_case.clone();
    if key.len() > 100 {
        key = key[..100].to_string();
    }
    key = format!("{}_{}", key, code);

    // Convert to uppercase and always append the code number
    let mut const_name = format!("{}_{}", snake_case.to_uppercase(), code);

    // Ensure it starts with a letter
    if const_name
        .chars()
        .next()
        .map_or(true, |c| !c.is_alphabetic())
    {
        const_name = format!("D_{}", const_name);
    }

    (const_name, key)
}

fn to_json_string(s: &str) -> String {
    // Use serde_json to properly escape the string
    // but with HTML escape disabled
    match serde_json::to_string(s) {
        Ok(json_str) => json_str,
        Err(_) => format!("\"{}\"", s.replace("\"", "\\\"")),
    }
}
